# File: pa4.py
# Author:     
# Date: 
# Description: 
import math

def solve(size, filename):
    """
    Solves the Sudoku problem specified in input file filename.
    The size of the problem is size.  (For example, for a 9 x 9 Sudoku,
    size is 9.)
    Returns a tuple of size 2.  The first element is a nested list containing
    the solution to the problem (row is the first index, col the second).
    The second element of the tuple is the number of nodes in the state space
    tree that were generated by your solution.
    """
    SUDOKU_OFFSET = 1
    sudoku_twentyfive_elements = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 
        'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y']
    sudoku_nineteen_elements = [1, 2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D', 'E', 'F', 'G']
    sudoku_nine_elements = [1,2,3,4,5,6,7,8,9]

    #part 1-->parse data into a 2d matrix

    #dictionary where key is the tuple location and val is the value at that location
    locations = get_locations(filename)

    sudoku_array_return = load_sudoku_array(filename,SUDOKU_OFFSET,locations)
    sudoku_array = sudoku_array_return[0]
    dimension = sudoku_array_return[1]

    #part 2 --> set up recursion and solve

    #create dictonary of sets to be used later


    sets = load_set_dicts(dimension,locations,SUDOKU_OFFSET)
    set_dict_rows = sets[0]
    set_dict_cols = sets[1]
    set_dict_sub_square = sets[2]
    print(f"set dict rows {set_dict_rows}\nset dict cols {set_dict_cols}\nset dict sub squares {set_dict_sub_square}")
    print(f"subsquare {get_subsquare(9,1,4)}")
    pass

def load_set_dicts(dimension, locations, sudoku_offset):
    dimension_set = set()
    set_dict_rows = {}
    set_dict_cols = {}
    set_dict_sub_square = {}
    if(dimension==9):
        dimension_set = {1,2,3,4,5,6,7,8,9}
    elif(dimension==16):
        dimension_set = {1, 2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D', 'E', 'F', 'G'}
    else:
        dimension_set = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 
        'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y'}
    for i in range(dimension):
        set_dict_rows[i+sudoku_offset] = dimension_set.copy()
        set_dict_cols[i+sudoku_offset] = dimension_set.copy()
        set_dict_sub_square[i+sudoku_offset] = dimension_set.copy()
    for key in locations:
        val = locations[key]
        set_dict_rows[key[0]].discard(val)
        set_dict_cols[key[1]].discard(val)
        sub_square_num = get_subsquare(dimension,key[0],key[1])
        set_dict_sub_square[sub_square_num].discard(val)
    return set_dict_rows,set_dict_cols,set_dict_sub_square

def get_subsquare(dimension,row,col):
    """
    This helper method takes an x,y cordinate and sudoku dimensions and returns what subsquare it is within
    This returns an int in which subsquare 1 top left corner and len(dimension) subsquare is the bottom right square
    """

    # Determine the size of each subsquare based on the given dimension
    subsquare_size = int(math.sqrt(dimension))

    # # # Determine the row and column of the subsquare based on the given coordinates
    subsquare_row = (row - 1) // subsquare_size
    subsquare_col = (col - 1) // subsquare_size
    
    # Determine the subsquare number based on the row and column
    subsquare_num = subsquare_row * (dimension // subsquare_size) + subsquare_col + 1

    return subsquare_num
    
def solve_recursive(row,col,sudoku_array,sudoku_offset, possible_rows_dict, possible_cols_dict,possible_sub_square_dict,num_nodes,solution_list):
    """
    This method is the recursive method for solve
    @params
        x and y are both ints which are cordinates
        sudoku_array is the array at this current step
        sudoku_offset is the offset into our list from our game
        possible_x is a set with all possible vals for our val to be based on column
        possible_y is a set with all possible vals for our val to be based on row
        possible_square is a set with all possible vals for our val to be based on sub square
        num_nodes are nodes so far to solve problem
        dimension_sqrt is an int which gets square root of the dimensions used for the possible_square
    This method will return a tuple with sudoku_array as index 0 and num nodes as index 1
    """

    list_len = len(sudoku_array)
    num_nodes+=1
    #last iteration
    #when x==list_len and y==1 we will iterate that time and call with y=0
    if(row==list_len and col==list_len):
        solution_list.append(sudoku_array)
        return solution_list,num_nodes
    else:
        possible_vals = []
        if()
    

def get_poss_vals(possible_rows_dict, possible_cols_dict,possible_sub_square_dict,row,col,sub_sqr_num):
    """
    This method gets the possible values to later be iterated over.
    This method returns a list of all possible values can be at row, col
    """
    possible_vals = []
    min_choices_list = []
    if(len(possible_cols_dict[col])<len(possible_rows_dict[row])and len(possible_cols_dict[col])<)


def load_sudoku_array(filename,sudoku_offset,locations):
    """
    This method creates the sudoku array.
    It returns an array where the pre-defined values are at their x,y cordinates.
        If there is no current val at that location then there is None at that cordinate
    """

    #find max row and col value by searching locations
    dimension = get_dimension(locations)
    sudoku_array = []
    for i in range(dimension):
        inner_array = []
        for j in range(dimension):
            try:
                val = locations[i+sudoku_offset,j+sudoku_offset]
                inner_array.append(val)
            except:
                inner_array.append(None)
        sudoku_array.append(inner_array)
    return sudoku_array,dimension




def get_locations(filename):
    """
    This method is a helper method to load_sudoku_array to find pre defined locaitons
    It returns a dictonary  where key is the tuple location and val is the value at that location
    """
    locations = {}
    with open(filename, 'r') as f:
        for line in f:
            line_list = line.split()
            locations[int(line_list[0]),int(line_list[1])] = int(line_list[2])
    return locations

def get_dimension(locations):
    """
    This method finds the dimension to later be used for creating 2D array in Solve
    locations is dict where key is the tuple location and val is the value at that location
    """  
    dimension = 0
    for pair in locations.keys():
        if(pair[0]>dimension):
            dimension = pair[0]
    return dimension

if __name__ == "__main__":
    SIZE = 9
    FILENAME = "p1.txt"
    solution = solve(SIZE, FILENAME)
    # if not solution[0]:
    #     print("No solution")
    # else:
    #     print(solution[0])
    # print(f"Nodes generated = {solution[1]}")