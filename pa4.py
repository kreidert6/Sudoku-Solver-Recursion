# File: pa4.py
# Author:     
# Date: 
# Description: 
import math
import copy

def solve(size, filename):
    """
    Solves the Sudoku problem specified in input file filename.
    The size of the problem is size.  (For example, for a 9 x 9 Sudoku,
    size is 9.)
    Returns a tuple of size 2.  The first element is a nested list containing
    the solution to the problem (row is the first index, col the second).
    The second element of the tuple is the number of nodes in the state space
    tree that were generated by your solution.
    """
    SUDOKU_OFFSET = 1
    sudoku_twentyfive_elements = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 
        'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y']
    sudoku_sixteen_elements = ['1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G']
    sudoku_nine_elements = ['1','2','3','4','5','6','7','8','9']

    #part 1-->parse data into a 2d matrix

    #dictionary where key is the tuple location and val is the value at that location
    locations = get_locations(filename)

    sudoku_array_return = load_sudoku_array(filename,SUDOKU_OFFSET,locations)
    sudoku_array = sudoku_array_return[0]
    dimension = sudoku_array_return[1]

    #part 2 --> set up recursion and solve

    #create dictonary of sets to be used later
    row = 1
    col = 1

    sets = load_set_dicts(dimension,locations,SUDOKU_OFFSET)
    possible_rows_dict = sets[0]
    possible_cols_dict = sets[1]
    possible_sub_square_dict = sets[2]



    # current_location = get_next_row_col(sudoku_array, (row, col), SUDOKU_OFFSET)
    # row = current_location[0]
    # col = current_location[1]
    next_box = get_next_row_col(sudoku_array, SUDOKU_OFFSET)
    row = next_box[0]
    col = next_box[1]
    

    sub_sqr_num = get_subsquare(dimension, row, col)

    #possible_vals = get_poss_vals(possible_rows_dict, possible_cols_dict,possible_sub_square_dict,row,col,sub_sqr_num)

    dimension = len(sudoku_array)
    

    




    num_nodes = [0]

    #print(solve_recursive(row,col,sudoku_array,SUDOKU_OFFSET, possible_rows_dict, possible_cols_dict,possible_sub_square_dict,0))

    if dimension == 9:

        solution, num_nodes = solve_recursive(sudoku_array, num_nodes, sudoku_nine_elements, possible_rows_dict, possible_cols_dict, possible_sub_square_dict)
    elif dimension == 16:
        solution, num_nodes = solve_recursive(sudoku_array, num_nodes, sudoku_sixteen_elements, possible_rows_dict, possible_cols_dict, possible_sub_square_dict)
    else:
        solution, num_nodes = solve_recursive(sudoku_array, num_nodes, sudoku_twentyfive_elements, possible_rows_dict, possible_cols_dict, possible_sub_square_dict)

    
    
    print(solution)
    print(sudoku_array)
    print(num_nodes)
    #print(num_nodes)

    return (sudoku_array, num_nodes)
    



    # print(f"set dict rows {possible_rows_dict}\nset dict cols {possible_cols_dict}\nset dict sub squares {possible_sub_square_dict}")
    # print(f"subsquare {get_subsquare(9,1,4)}")
    # print("sudoku array", sudoku_array)
  

def check_if_valid(sudoku_array, attempt, row, col):
    
    row_values = sudoku_array[row-1]


    col_values = []
    
    for i in range(len(row_values)):
        col_values.append(sudoku_array[i][col-1])

    if attempt in row_values or attempt in col_values:
        return False
    
    dimension = len(sudoku_array)

    

    sqrt = int(math.sqrt(dimension))
   

    top_row = (row // sqrt) * sqrt
    first_col = (col // sqrt) * sqrt

    

    for i in range(top_row, top_row + int(math.sqrt(dimension))):
        for j in range(first_col, first_col + int(math.sqrt(dimension))):
            if sudoku_array[i][j] == attempt:
                return False
            
    return True
    



def load_set_dicts(dimension, locations, sudoku_offset):
    dimension_set = set()
    set_dict_rows = {}
    set_dict_cols = {}
    set_dict_sub_square = {}
    if(dimension==9):
        dimension_set = {'1','2','3','4','5','6','7','8','9'}
    elif(dimension==16):
        dimension_set = {'1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G'}
    else:
        dimension_set = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 
        'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y'}
    for i in range(dimension):
        set_dict_rows[i+sudoku_offset] = dimension_set.copy()
        set_dict_cols[i+sudoku_offset] = dimension_set.copy()
        set_dict_sub_square[i+sudoku_offset] = dimension_set.copy()
    for key in locations:
        val = locations[key]
        set_dict_rows[key[0]].discard(val)
        set_dict_cols[key[1]].discard(val)
        sub_square_num = get_subsquare(dimension,key[0],key[1])
        set_dict_sub_square[sub_square_num].discard(val)
    return set_dict_rows,set_dict_cols,set_dict_sub_square

def get_subsquare(dimension,row,col):
    """
    This helper method takes an x,y cordinate and sudoku dimensions and returns what subsquare it is within
    This returns an int in which subsquare 1 top left corner and len(dimension) subsquare is the bottom right square
    """

    # Determine the size of each subsquare based on the given dimension
    subsquare_size = int(math.sqrt(dimension))

    # # # Determine the row and column of the subsquare based on the given coordinates
    subsquare_row = (row - 1) // subsquare_size
    subsquare_col = (col - 1) // subsquare_size
    
    # Determine the subsquare number based on the row and column
    subsquare_num = subsquare_row * (dimension // subsquare_size) + subsquare_col + 1

    return subsquare_num

# def solve_recursive(row,col,sudoku_array,sudoku_offset, possible_rows_dict, possible_cols_dict,possible_sub_square_dict,num_nodes):
def solve_recursive(sudoku_array, num_nodes, elements, possible_rows_dict, possible_cols_dict,possible_sub_square_dict):
    """
    This method is the recursive method for solve
    @params
        x and y are both ints which are cordinates
        sudoku_array is the array at this current step
        sudoku_offset is the offset into our list from our game
        possible_x is a set with all possible vals for our val to be based on column
        possible_y is a set with all possible vals for our val to be based on row
        possible_square is a set with all possible vals for our val to be based on sub square
        num_nodes are nodes so far to solve problem
        dimension_sqrt is an int which gets square root of the dimensions used for the possible_square
    This method will return a tuple with sudoku_array as index 0 and num nodes as index 1
    """

    dimension = len(sudoku_array)
    num_nodes[0] += 1
    
    


    row, col = get_next_row_col(sudoku_array, 1)
    

    if row is None:  
        return True, num_nodes[0] 
    
    sub_sqr_num = get_subsquare(dimension, row, col)

    possible_vals = get_poss_vals(possible_rows_dict, possible_cols_dict,possible_sub_square_dict,row,col,sub_sqr_num)



    for attempt in possible_vals:
        possible_rows_dict_copy = copy.deepcopy(possible_rows_dict)
        possible_cols_dict_copy = copy.deepcopy(possible_cols_dict)
        possible_sub_square_dict_copy = copy.deepcopy(possible_sub_square_dict)
        possible_rows_dict_copy[row].discard(attempt)
        possible_cols_dict_copy[col].discard(attempt)
        possible_sub_square_dict_copy[sub_sqr_num].discard(attempt)

        # if check_if_valid(sudoku_array, attempt, row, col):
        sudoku_array[row-1][col-1] = attempt
        skip = False
        # for r in range(len(sudoku_array)):
        #     for c in range(len(sudoku_array)):
        #         if sudoku_array[r][c] == None:
        #             sub_sqr_num_temp = get_subsquare(dimension, r+1, c+1)
        #             possible_vals_temp = get_poss_vals(possible_rows_dict_copy, possible_cols_dict_copy,possible_sub_square_dict_copy,r+1,c+1,sub_sqr_num_temp)
        #             if len(possible_vals_temp) == 1:
        #                 new_val = possible_vals_temp.pop()
        #                 sudoku_array[r][c] = new_val
        #                 possible_rows_dict_copy[r+1].discard(new_val)
        #                 possible_cols_dict_copy[c+1].discard(new_val)
        #                 possible_sub_square_dict_copy[sub_sqr_num_temp].discard(new_val)

        #             elif len(possible_vals_temp) == 0:
        #                 skip = True


        if solve_recursive(sudoku_array, num_nodes, elements, possible_rows_dict_copy, possible_cols_dict_copy, possible_sub_square_dict_copy)[0] and not skip:
            return True, num_nodes[0]
            
        sudoku_array[row-1][col-1] = None

    return False, num_nodes[0]


    # last iteration
    # when x==list_len and y==1 we will iterate that time and call with y=0
    

    # if(row==dimension and col==dimension):
    #     # solution_list.append(sudoku_array)
    #     #return solution_list,num_nodes
    #     return sudoku_array, num_nodes
    # elif:

    #     sub_sqr_num = get_subsquare(dimension, row, col)
    #     possible_vals = get_poss_vals(possible_rows_dict, possible_cols_dict, possible_sub_square_dict, row, col, sub_sqr_num)
        
    #     next = get_next_row_col(sudoku_array, (row,col), sudoku_offset )
        
    #     next_row = next[0]
    #     next_col = next[1]

        
        # for val in possible_vals:

        #     sudoku_copy = copy.deepcopy(sudoku_array)
        #     sudoku_copy[row - sudoku_offset][col - sudoku_offset] = val
            

        #     possible_rows_dict[row].discard(val)
        #     possible_cols_dict[col].discard(val)
        #     possible_sub_square_dict[sub_sqr_num].discard(val)

            
        #     temp = solve_recursive(next_row,next_col,sudoku_copy,sudoku_offset, possible_rows_dict, possible_cols_dict,possible_sub_square_dict,num_nodes)
    
        #     if temp:
        #         return temp
            
        # return None


def get_poss_vals(possible_rows_dict, possible_cols_dict,possible_sub_square_dict,row,col,sub_sqr_num):
    """
    This method gets the possible values to later be iterated over.
    This method returns a set of all possible values can be at row, col
    """
  
    return possible_rows_dict[row].intersection(possible_cols_dict[col], possible_sub_square_dict[sub_sqr_num])

    


def load_sudoku_array(filename,sudoku_offset,locations):
    """
    This method creates the sudoku array.
    It returns an array where the pre-defined values are at their x,y cordinates.
        If there is no current val at that location then there is None at that cordinate
    """

    #find max row and col value by searching locations
    dimension = get_dimension(locations)
    sudoku_array = []
    for i in range(dimension):
        inner_array = []
        for j in range(dimension):
            try:
                val = locations[i+sudoku_offset,j+sudoku_offset]
                inner_array.append(val)
            except:
                inner_array.append(None)
        sudoku_array.append(inner_array)
    return sudoku_array,dimension




def get_locations(filename):
    """
    This method is a helper method to load_sudoku_array to find pre defined locaitons
    It returns a dictonary  where key is the tuple location and val is the value at that location
    """
    locations = {}
    with open(filename, 'r') as f:
        for line in f:
            line_list = line.split()
            locations[int(line_list[0]),int(line_list[1])] = line_list[2]
    return locations

def get_dimension(locations):
    """
    This method finds the dimension to later be used for creating 2D array in Solve
    locations is dict where key is the tuple location and val is the value at that location
    """  
    dimension = 0
    for pair in locations.keys():
        if(pair[0]>dimension):
            dimension = pair[0]
    return dimension


# def get_next_row_col(sudoku_array, last_insert, sudoku_offset):
#     found = False
#     row = last_insert[0] 
#     col = last_insert[1]  

    

#     while not found:
        
#         if col != len(sudoku_array):
#             col += 1
#             cur = sudoku_array[row - sudoku_offset][ col - sudoku_offset]
#         else: 
#             row += 1
#             col = 1
#             cur = sudoku_array[row - sudoku_offset][col - sudoku_offset]

#         if cur == None:
#             found = True

#     return (row,col)


def get_next_row_col(sudoku_array, offset):

    for r in range(len(sudoku_array)):
        for c in range(len(sudoku_array)):

            #if this spot is empty
            if sudoku_array[r][c] == None:
                return r+1,c+1
            
    #if no more boxes to fill, puzzle complete
    return None, None


        




if __name__ == "__main__":
    SIZE = 9
    FILENAME = "p1.txt"
    solution = solve(SIZE, FILENAME)
    # if not solution[0]:
    #     print("No solution")
    # else:
    #     print(solution[0])
    # print(f"Nodes generated = {solution[1]}")