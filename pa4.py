# File: pa4.py
# Author: Garrett and Tyler
# Date: 5-22-2023
# Description: This solution implements a backtracking algorithim to solve the sodoku game with varying difficulty and input size
import math
import copy
from collections import Counter


def solve(size, filename):
    """
    Solves the Sudoku problem specified in input file filename.
    The size of the problem is size.  (For example, for a 9 x 9 Sudoku,
    size is 9.)
    Returns a tuple of size 2.  The first element is a nested list containing
    the solution to the problem (row is the first index, col the second).
    The second element of the tuple is the number of nodes in the state space
    tree that were generated by your solution.
    """
    SUDOKU_OFFSET = 1

    #dictionary where key is the tuple location and val is the value at that location
    locations = get_locations(filename)

    #load the sudoku board with the initial starting values
    sudoku_array_return = load_sudoku_array(SUDOKU_OFFSET,locations)
    sudoku_array = sudoku_array_return[0]
    dimension = sudoku_array_return[1]


    #part 2 --> set up recursion and solve

    #find the possible values for the possible corresponding row, column, subsqr alone
    sets = load_set_dicts(dimension,locations,SUDOKU_OFFSET)
    possible_rows_dict = sets[0]
    possible_cols_dict = sets[1]
    possible_sub_square_dict = sets[2]

    #create subsquare starting cords
    subsquare_starting_cord = {9:[(1,1),(1,4),(1,7),(4,1),(4,4),(4,7),(7,1),(7,4),(7,7)], 
        16:[(1,1),(1,5),(1,9),(1,13),(5,1),(5,5),(5,9),(5,13),(9,1),(9,5),(9,9),(9,13),(13,1),(13,5),(13,9),(13,13)],
        25:[(1,1),(1,6),(1,11),(1,16),(1,21),(6,1),(6,6),(6,11),(6,16),(6,21),(11,1),(11,6),(11,11),(11,16),(11,21),(16,1),(16,6),(16,11),(16,16),(16,21),
            (21,1),(21,6),(21,11),(21,16),(21,21)]}

    #grab next square to insert into
    row,col = get_next_row_col(sudoku_array,SUDOKU_OFFSET)
    dimension = len(sudoku_array)
    
    num_nodes = [0]


    #call cutoffs before we start any guessing
    sudoku_array, breakBranch= cuttoffs(sudoku_array,row,col,possible_rows_dict,possible_cols_dict,possible_sub_square_dict,subsquare_starting_cord)

    #call the function that starts guessing
    solution, num_nodes = solve_recursive(sudoku_array, num_nodes, possible_rows_dict, possible_cols_dict, possible_sub_square_dict,subsquare_starting_cord)
    print(solution)
    print(num_nodes)
    return (solution, num_nodes)

def solve_recursive(sudoku_array, num_nodes, possible_rows_dict, possible_cols_dict,possible_sub_square_dict,subsquare_starting_cord):
    """
    This method is the recursive method for solve
    @params
        x and y are both ints which are cordinates
        sudoku_array is the array at this current step
        sudoku_offset is the offset into our list from our game
        possible_x is a set with all possible vals for our val to be based on column
        possible_y is a set with all possible vals for our val to be based on row
        possible_square is a set with all possible vals for our val to be based on sub square
        num_nodes are nodes so far to solve problem
        dimension_sqrt is an int which gets square root of the dimensions used for the possible_square
    This method will return a tuple with sudoku_array as index 0 and num nodes as index 1
    """

    dimension = len(sudoku_array)
    num_nodes[0] += 1
    row, col = get_next_row_col(sudoku_array, 1)
    
    #if the board is complete (no more empty squares)
    if row is None:  
        return sudoku_array, num_nodes[0] 

    sub_sqr_num = get_subsquare(dimension, row, col)


    #numbers that work for this particular square at this instance
    possible_vals = get_poss_vals(possible_rows_dict, possible_cols_dict,possible_sub_square_dict,row,col,sub_sqr_num)
    
    
    #we are attempting each value from the list of possible values at this particular box
    for attempt in possible_vals:
        breakBranch = False
        sudoku_array_copy = copy.deepcopy(sudoku_array)
        possible_rows_dict_copy = copy.deepcopy(possible_rows_dict)
        possible_cols_dict_copy = copy.deepcopy(possible_cols_dict)
        possible_sub_square_dict_copy = copy.deepcopy(possible_sub_square_dict)
        possible_rows_dict_copy[row].discard(attempt)
        possible_cols_dict_copy[col].discard(attempt)
        possible_sub_square_dict_copy[sub_sqr_num].discard(attempt)


        #assign to sudoku board
        sudoku_array_copy[row-1][col-1] = attempt

        #since we changed the board, check for new cutoffs
        sudoku_array_copy, breakBranch= cuttoffs(sudoku_array_copy,row,col,possible_rows_dict_copy,possible_cols_dict_copy,possible_sub_square_dict_copy,subsquare_starting_cord)
        return_array = []

        if(not breakBranch):
            return_array,count = solve_recursive(sudoku_array_copy, num_nodes, possible_rows_dict_copy, possible_cols_dict_copy, possible_sub_square_dict_copy,subsquare_starting_cord)
        if return_array:
            return return_array, count

    return None, num_nodes[0]

def cuttoffs(sudoku_array_copy,row,col,possible_rows_dict_copy, possible_cols_dict_copy,possible_sub_square_dict_copy,subsquare_starting_cord):
    """
    This method does cutoffs to prevent the solution going down wrong paths.
    It will return the array and the breackBranch (which will be used to determine if going down bad branch)
    """

    changes = True
    breakBranch = False
    dimension = len(sudoku_array_copy)
    

    #this will continue until it completes an iteration without changing any squares on the board
    while changes:
        changes = False
        

        #this loop completes the cutoffs for each row
        for r in range(1, len(sudoku_array_copy)+1):
            temp_dict = {}
            for c in range(1, len(sudoku_array_copy)+1):
                if sudoku_array_copy[r-1][c-1] is None:
                    sub_sqr_num_temp = get_subsquare(dimension, r, c)

                    #evaluate new possible values for this specific box
                    possible_vals = get_poss_vals(possible_rows_dict_copy, possible_cols_dict_copy,possible_sub_square_dict_copy,r,c,sub_sqr_num_temp)

                    #if there are no possible valid values, break
                    if len(possible_vals) == 0:
                        breakBranch = True
                        return sudoku_array_copy,breakBranch

                    #if there is only one possible valid value, immediately place it in the board
                    if len(possible_vals) == 1:
                        changes = True
                        new_val = possible_vals.pop()
                        
                        sudoku_array_copy[r-1][c-1] = new_val
                        possible_rows_dict_copy[r].discard(new_val)
                        possible_cols_dict_copy[c].discard(new_val)
                        possible_sub_square_dict_copy[sub_sqr_num_temp].discard(new_val)

                        #remove the item from values within the temp_dict
                        for item in temp_dict:                            
                            temp_dict[item].discard(new_val)

                    temp_dict[c] = possible_vals 

            #try to return a unique number within the possible values of all boxes within a row
            unique_num_return =  find_unique_number(temp_dict,sudoku_array_copy,r)
            

            #cutoff 2 (if theres is a unique possible value)
            if(unique_num_return is not None): 
                unique_num = unique_num_return[0]
                unique_num_col = unique_num_return[1]
                sub_sqr_num_temp = get_subsquare(dimension,r,unique_num_col)
                sudoku_array_copy[r-1][unique_num_col-1] = unique_num
                changes = True
                possible_rows_dict_copy[r].discard(unique_num)
                possible_cols_dict_copy[unique_num_col].discard(unique_num)
                possible_sub_square_dict_copy[sub_sqr_num_temp].discard(unique_num)
                temp_dict[unique_num_col].discard(unique_num)


        #this loop checks for cutoffs for each column
        for c in range(1, len(sudoku_array_copy)+1):
            temp_dict = {}
            for r in range(1, len(sudoku_array_copy)+1):
             
                if sudoku_array_copy[r-1][c-1] is None:
                    sub_sqr_num_temp = get_subsquare(dimension, r, c)

                    #evaluate new possible values for this specific box
                    possible_vals = get_poss_vals(possible_rows_dict_copy, possible_cols_dict_copy,possible_sub_square_dict_copy,r,c,sub_sqr_num_temp)
            
                    temp_dict[r] = possible_vals
                    
            #try to return a unique number within the possible values of all boxes within a column
            unique_num_return =  find_unique_number(temp_dict,sudoku_array_copy,c)
            

            #cutoff 2 (if theres is a unique possible value)
            if(unique_num_return is not None):
                
               
                unique_num = unique_num_return[0]
                unique_num_row = unique_num_return[1]
                
                sub_sqr_num_temp = get_subsquare(dimension,unique_num_row,c)
                sudoku_array_copy[unique_num_row-1][c-1] = unique_num
                changes = True
                possible_rows_dict_copy[unique_num_row].discard(unique_num)
                possible_cols_dict_copy[c].discard(unique_num)
                possible_sub_square_dict_copy[sub_sqr_num_temp].discard(unique_num)
                temp_dict[unique_num_row].discard(unique_num)



        #grabs all the starting coordinates of the top left box in each subsquare
        list_to_iterate = subsquare_starting_cord[dimension]
        sqrt = int(math.sqrt(dimension))

        #this loop checks for cutoffs for each subsquare
        for cord in list_to_iterate:
            temp_dict = {}
            for r in range(cord[0], cord[0]+sqrt):
                for c in range(cord[1], cord[1]+ sqrt):
                    if sudoku_array_copy[r-1][c-1] is None:
                        sub_sqr_num_temp = get_subsquare(dimension, r, c)

                        #evaluate new possible values for this specific box
                        possible_vals = get_poss_vals(possible_rows_dict_copy, possible_cols_dict_copy,possible_sub_square_dict_copy,r,c,sub_sqr_num_temp)
                        temp_dict[r,c] = possible_vals
                    
            #try to return a unique number within the possible values of all boxes within a subsqr
            unique_num_return =  find_unique_number(temp_dict,sudoku_array_copy,c)
            
            #cutoff 2 (if theres is a unique possible value)
            if(unique_num_return is not None):
                
                unique_num = unique_num_return[0]
                unique_num_cord = unique_num_return[1]
                row = unique_num_cord[0]
                col = unique_num_cord[1]
                sub_sqr_num_temp = get_subsquare(dimension,row,col)
                sudoku_array_copy[row-1][col-1] = unique_num
                changes = True
                possible_rows_dict_copy[row].discard(unique_num)
                possible_cols_dict_copy[col].discard(unique_num)
                possible_sub_square_dict_copy[sub_sqr_num_temp].discard(unique_num)
                temp_dict[row,col].discard(unique_num)
            
    return sudoku_array_copy,breakBranch
    
   


def find_unique_number(dictionary,sudoku_array,col):
    """"
    This method is a helper function to get the unique number within the dictonary
    It will return num which is the number it found and key which is the associated key in the dictonary
    """
    combined_list = [num for sublist in dictionary.values() for num in sublist]
    counts = Counter(combined_list)
    
    for key, values in dictionary.items():
        for num in values:
            if counts[num] == 1:
                return num, key
    
    return None
    

def load_set_dicts(dimension, locations, sudoku_offset):
    """
    This method loads the possible values for the dictonaries to be used later.
    It will be called in solve method.
    It returns a tuples of 3 dictionaries
    """
    dimension_set = set()
    set_dict_rows = {}
    set_dict_cols = {}
    set_dict_sub_square = {}
    if(dimension==9):
        dimension_set = {'1','2','3','4','5','6','7','8','9'}
    elif(dimension==16):
        dimension_set = {'1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G'}
    else:
        dimension_set = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 
        'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y'}
    for i in range(dimension):
        set_dict_rows[i+sudoku_offset] = dimension_set.copy()
        set_dict_cols[i+sudoku_offset] = dimension_set.copy()
        set_dict_sub_square[i+sudoku_offset] = dimension_set.copy()
    for key in locations:
        val = locations[key]
        set_dict_rows[key[0]].discard(val)
        set_dict_cols[key[1]].discard(val)
        sub_square_num = get_subsquare(dimension,key[0],key[1])
        set_dict_sub_square[sub_square_num].discard(val)
    return set_dict_rows,set_dict_cols,set_dict_sub_square

def get_subsquare(dimension,row,col):
    """
    This helper method takes an x,y cordinate and sudoku dimensions and returns what subsquare it is within
    This returns an int in which subsquare 1 top left corner and len(dimension) subsquare is the bottom right square
    """

    # Determine the size of each subsquare based on the given dimension
    subsquare_size = int(math.sqrt(dimension))

    # # # Determine the row and column of the subsquare based on the given coordinates
    subsquare_row = (row - 1) // subsquare_size
    subsquare_col = (col - 1) // subsquare_size
    
    # Determine the subsquare number based on the row and column
    subsquare_num = subsquare_row * (dimension // subsquare_size) + subsquare_col + 1

    return subsquare_num




def get_poss_vals(possible_rows_dict, possible_cols_dict,possible_sub_square_dict,row,col,sub_sqr_num):
    """
    This method gets the possible values to later be iterated over.
    This method returns a set of all possible values can be at row, col
    """
  
    return possible_rows_dict[row].intersection(possible_cols_dict[col], possible_sub_square_dict[sub_sqr_num])

    


def load_sudoku_array(sudoku_offset,locations):
    """
    This method creates the sudoku array.
    It returns an array where the pre-defined values are at their x,y cordinates.
        If there is no current val at that location then there is None at that cordinate
        It will also return a Queue of locations with no assigned value
    """
    #find max row and col value by searching locations
    dimension = get_dimension(locations)
    sudoku_array = []
    for i in range(dimension):
        inner_array = []
        for j in range(dimension):
            try:
                val = locations[i+sudoku_offset,j+sudoku_offset]
                inner_array.append(val)
            except:
                inner_array.append(None)
        sudoku_array.append(inner_array)
    return sudoku_array,dimension




def get_locations(filename):
    """
    This method is a helper method to load_sudoku_array to find pre defined locaitons
    It returns a dictonary  where key is the tuple location and val is the value at that location
    """
    locations = {}
    with open(filename, 'r') as f:
        for line in f:
            line_list = line.split()
            locations[int(line_list[0]),int(line_list[1])] = line_list[2]
    return locations

def get_dimension(locations):
    """
    This method finds the dimension to later be used for creating 2D array in Solve
    locations is dict where key is the tuple location and val is the value at that location
    """  
    dimension = 0
    for pair in locations.keys():
        if(pair[0]>dimension):
            dimension = pair[0]
    return dimension





def get_next_row_col(sudoku_array, offset):
    """
    This method returns the coordinate of the next square that doesn't hold a value yet
    
    """

    for r in range(len(sudoku_array)):
        for c in range(len(sudoku_array)):

            #if this spot is empty
            if sudoku_array[r][c] == None:
                return r+1,c+1
            
    #if no more boxes to fill, puzzle complete
    return None, None


        




if __name__ == "__main__":
    SIZE = 9
    FILENAME = "p1.txt"
    solution = solve(SIZE, FILENAME)
   