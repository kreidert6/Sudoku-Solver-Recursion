# File: pa4.py
# Author:     
# Date: 
# Description: 
import math
import copy
from collections import Counter

class Queue:
    def __init__(self):
        self.items = []
    
    def is_empty(self):
        return not bool(self.items)
    
    def enqueue(self, item):
        self.items.append(item)
    
    def dequeue(self):
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.items.pop(0)
    
    def __len__(self):
        return len(self.items)
    
    def __deepcopy__(self, memo):
        new_queue = self.__class__()
        memo[id(self)] = new_queue
        for item in self.items:
            new_queue.enqueue(copy.deepcopy(item, memo))
        return new_queue

    def remove(self, item):
        if item in self.items:
            self.items.remove(item)

def solve(size, filename):
    """
    Solves the Sudoku problem specified in input file filename.
    The size of the problem is size.  (For example, for a 9 x 9 Sudoku,
    size is 9.)
    Returns a tuple of size 2.  The first element is a nested list containing
    the solution to the problem (row is the first index, col the second).
    The second element of the tuple is the number of nodes in the state space
    tree that were generated by your solution.
    """
    SUDOKU_OFFSET = 1

    #dictionary where key is the tuple location and val is the value at that location
    locations = get_locations(filename)

    sudoku_array_return = load_sudoku_array(SUDOKU_OFFSET,locations)
    sudoku_array = sudoku_array_return[0]
    dimension = sudoku_array_return[1]
    open_points_queue = sudoku_array_return[2]

    #part 2 --> set up recursion and solve

    sets = load_set_dicts(dimension,locations,SUDOKU_OFFSET)
    possible_rows_dict = sets[0]
    possible_cols_dict = sets[1]
    possible_sub_square_dict = sets[2]



    # current_location = get_next_row_col(sudoku_array, (row, col), SUDOKU_OFFSET)
    # row = current_location[0]
    # col = current_location[1]
    # next_box = get_next_row_col(sudoku_array, SUDOKU_OFFSET)
    # row = next_box[0]
    # col = next_box[1]
    
    row, col = open_points_queue.dequeue()
    dimension = len(sudoku_array)
    
    num_nodes = [0]

    #print(solve_recursive(row,col,sudoku_array,SUDOKU_OFFSET, possible_rows_dict, possible_cols_dict,possible_sub_square_dict,0))

    # if dimension == 9:

    #     solution, num_nodes = solve_recursive(sudoku_array, num_nodes, sudoku_nine_elements, possible_rows_dict, possible_cols_dict, possible_sub_square_dict,open_points_queue)
    # elif dimension == 16:
    #     solution, num_nodes = solve_recursive(sudoku_array, num_nodes, sudoku_sixteen_elements, possible_rows_dict, possible_cols_dict, possible_sub_square_dict,open_points_queue)
    # else:
    #     solution, num_nodes = solve_recursive(sudoku_array, num_nodes, sudoku_twentyfive_elements, possible_rows_dict, possible_cols_dict, possible_sub_square_dict,open_points_queue)

    sudoku_array, breakBranch= cuttoffs(sudoku_array,row,col,possible_rows_dict,possible_cols_dict,possible_sub_square_dict)

    solution, num_nodes = solve_recursive(sudoku_array, num_nodes, possible_rows_dict, possible_cols_dict, possible_sub_square_dict,open_points_queue)
    # print(solution)
    # print(sudoku_array)
    print(solution)
    print(num_nodes)
    #print(num_nodes)

    return (solution, num_nodes)
    



    # print(f"set dict rows {possible_rows_dict}\nset dict cols {possible_cols_dict}\nset dict sub squares {possible_sub_square_dict}")
    # print(f"subsquare {get_subsquare(9,1,4)}")
    # print("sudoku array", sudoku_array)

# def solve_recursive(sudoku_array, num_nodes, elements, possible_rows_dict, possible_cols_dict,possible_sub_square_dict,open_points_queue):
def solve_recursive(sudoku_array, num_nodes, possible_rows_dict, possible_cols_dict,possible_sub_square_dict,open_points_queue):
    """
    This method is the recursive method for solve
    @params
        x and y are both ints which are cordinates
        sudoku_array is the array at this current step
        sudoku_offset is the offset into our list from our game
        possible_x is a set with all possible vals for our val to be based on column
        possible_y is a set with all possible vals for our val to be based on row
        possible_square is a set with all possible vals for our val to be based on sub square
        num_nodes are nodes so far to solve problem
        dimension_sqrt is an int which gets square root of the dimensions used for the possible_square
    This method will return a tuple with sudoku_array as index 0 and num nodes as index 1
    """

    dimension = len(sudoku_array)
    num_nodes[0] += 1
    row, col = get_next_row_col(sudoku_array, 1)
    # open_points_queue_copy = copy.deepcopy(open_points_queue)
    # row, col = open_points_queue.dequeue()
    
    if row is None:  
        return sudoku_array, num_nodes[0] 
    
    sub_sqr_num = get_subsquare(dimension, row, col)


    possible_vals = get_poss_vals(possible_rows_dict, possible_cols_dict,possible_sub_square_dict,row,col,sub_sqr_num)
    # if(len(possible_vals)==0):
    #     print("")
    
    for attempt in possible_vals:
        #create helper and process any cell with only 1 choice
        #3 possible vals with 4 but 4 not in poss in any others
        open_points_sub_queue_copy = copy.deepcopy(open_points_queue)
        breakBranch = False
        sudoku_array_copy = copy.deepcopy(sudoku_array)
        possible_rows_dict_copy = copy.deepcopy(possible_rows_dict)
        possible_cols_dict_copy = copy.deepcopy(possible_cols_dict)
        possible_sub_square_dict_copy = copy.deepcopy(possible_sub_square_dict)
        possible_rows_dict_copy[row].discard(attempt)
        possible_cols_dict_copy[col].discard(attempt)
        possible_sub_square_dict_copy[sub_sqr_num].discard(attempt)

        # if check_if_valid(sudoku_array, attempt, row, col):
        sudoku_array_copy[row-1][col-1] = attempt

        sudoku_array_copy, breakBranch= cuttoffs(sudoku_array_copy,row,col,possible_rows_dict_copy,possible_cols_dict_copy,possible_sub_square_dict_copy)
        return_array = []
        # sudoku_array_copy, breakBranch= cuttoffs(sudoku_array_copy,row,col,possible_rows_dict_copy,possible_cols_dict_copy,possible_sub_square_dict_copy)
        if(not breakBranch):
            return_array,count = solve_recursive(sudoku_array_copy, num_nodes, possible_rows_dict_copy, possible_cols_dict_copy, possible_sub_square_dict_copy,open_points_sub_queue_copy)
        if return_array:
            return return_array, count

    return None, num_nodes[0]

def cuttoffs(sudoku_array_copy,row,col,possible_rows_dict_copy, possible_cols_dict_copy,possible_sub_square_dict_copy):
    # sudoku_array_copy = copy.deepcopy(sudoku_array)
    # possible_rows_dict_copy = copy.deepcopy(possible_rows_dict)
    # possible_cols_dict_copy = copy.deepcopy(possible_cols_dict)
    # possible_sub_square_dict_copy = copy.deepcopy(possible_sub_square_dict)
    changes = True
    breakBranch = False
    dimension = len(sudoku_array_copy)
    
    while changes:
        changes = False
        final_poss_vals = {}

        for r in range(1, len(sudoku_array_copy)+1):
            temp_dict = {}
            for c in range(1, len(sudoku_array_copy)+1):
                # if r == 9 and c == 3:
                #     print("stop")
                
               
                if sudoku_array_copy[r-1][c-1] is None:
                    sub_sqr_num_temp = get_subsquare(dimension, r, c)
                    possible_vals = get_poss_vals(possible_rows_dict_copy, possible_cols_dict_copy,possible_sub_square_dict_copy,r,c,sub_sqr_num_temp)
            # poss_vals_for_row_dict[r] = copy.deepcopy(possible_vals)
                    # poss_vals_for_row_dict[r] = possible_vals
                    #
                    if len(possible_vals) == 0:
                        breakBranch = True
                        return sudoku_array_copy,breakBranch
                    #
                    #     return None, num_nodes[0]


                    #should this go below the if statement??
                    

                   
                    if len(possible_vals) == 1:
                        changes = True
                        new_val = possible_vals.pop()
                        
                        # poss_vals_for_row_dict[r].pop()
                        sudoku_array_copy[r-1][c-1] = new_val
                        possible_rows_dict_copy[r].discard(new_val)
                        possible_cols_dict_copy[c].discard(new_val)
                        possible_sub_square_dict_copy[sub_sqr_num_temp].discard(new_val)
                        # open_points_sub_queue_copy.remove((r+1,col))
                        for item in temp_dict:
                            
                            temp_dict[item].discard(new_val)


                        
                        

                    temp_dict[c] = possible_vals
                    

            unique_num_return =  find_unique_number(temp_dict,sudoku_array_copy,r)
            
            if(unique_num_return is not None):
                
               
                unique_num = unique_num_return[0]
                unique_num_col = unique_num_return[1]
                
                sub_sqr_num_temp = get_subsquare(dimension,r,unique_num_col)
                sudoku_array_copy[r-1][unique_num_col-1] = unique_num
                changes = True
                possible_rows_dict_copy[r].discard(unique_num)
                possible_cols_dict_copy[unique_num_col].discard(unique_num)
                possible_sub_square_dict_copy[sub_sqr_num_temp].discard(unique_num)
                temp_dict[unique_num_col].discard(unique_num)

    
        
    
    return sudoku_array_copy,breakBranch
    
    """
    

    #poss_vals_for_row will be a dictonary with 1-9 and the value will be the potnetial vals for that row number
    
    poss_vals_for_row_dict = {}
    dimension = len(sudoku_array_copy)
    for r in range(1,len(sudoku_array_copy)+1):
        if sudoku_array_copy[r-1][col-1] == None:
            sub_sqr_num_temp = get_subsquare(dimension, r, col)
            possible_vals = get_poss_vals(possible_rows_dict_copy, possible_cols_dict_copy,possible_sub_square_dict_copy,r,col,sub_sqr_num_temp)
            # poss_vals_for_row_dict[r] = copy.deepcopy(possible_vals)
            poss_vals_for_row_dict[r] = possible_vals
            if len(possible_vals) == 0:
                breakBranch = True
                continue
            #     return None, num_nodes[0]
            if len(possible_vals) == 1:
                new_val = possible_vals.pop()
                # poss_vals_for_row_dict[r].pop()
                sudoku_array_copy[r-1][col-1] = new_val
                possible_rows_dict_copy[r].discard(new_val)
                possible_cols_dict_copy[col].discard(new_val)
                possible_sub_square_dict_copy[sub_sqr_num_temp].discard(new_val)
                # open_points_sub_queue_copy.remove((r+1,col))

    
    


    if(not breakBranch):
        for c in range(1,len(sudoku_array_copy)+1):
            if sudoku_array_copy[row-1][c-1] == None:
                sub_sqr_num_temp = get_subsquare(dimension, row, c)
                possible_vals = get_poss_vals(possible_rows_dict_copy, possible_cols_dict_copy,possible_sub_square_dict_copy,row,c,sub_sqr_num_temp)
                if len(possible_vals) == 0:
                    breakBranch = True
                    continue
                #    return None, num_nodes[0]
                if len(possible_vals) == 1:
                    new_val = possible_vals.pop()
                    sudoku_array_copy[row-1][c-1] = new_val
                    possible_rows_dict_copy[row].discard(new_val)
                    possible_cols_dict_copy[c].discard(new_val)
                    possible_sub_square_dict_copy[sub_sqr_num_temp].discard(new_val)
                    # open_points_sub_queue_copy.remove((row,c+1))

    if(not breakBranch):
        sqrt = int(math.sqrt(dimension))
        top_row = (((row-1) // sqrt) * sqrt)+1
        first_col = (((col-1) // sqrt) * sqrt)+1

        for sub_row in range(top_row, top_row+sqrt):
            for sub_col in range(first_col, first_col+ sqrt):
                
                if sudoku_array_copy[sub_row-1][sub_col-1] == None:
                    sub_sqr_num_temp = get_subsquare(dimension, sub_row, sub_col)
                    possible_vals = get_poss_vals(possible_rows_dict_copy, possible_cols_dict_copy,possible_sub_square_dict_copy, sub_row, sub_col,sub_sqr_num_temp)
                    if len(possible_vals) == 0:
                        breakBranch = True
                        continue
                    #     return False, num_nodes[0]
                    if len(possible_vals) == 1:
                        new_val = possible_vals.pop()
                        sudoku_array_copy[sub_row-1][sub_col-1] = new_val
                        possible_rows_dict_copy[sub_row].discard(new_val)
                        possible_cols_dict_copy[sub_col].discard(new_val)
                        possible_sub_square_dict_copy[sub_sqr_num_temp].discard(new_val)

    """
    
        


def find_unique_number(dictionary,sudoku_array,col):
    """"
    This method is a helper function to get the unique number within the dictonary
    It will return num which is the number it found and key which is the associated key in the dictonary
    """
    combined_list = [num for sublist in dictionary.values() for num in sublist]
    counts = Counter(combined_list)
    
    for key, values in dictionary.items():
        for num in values:
            if counts[num] == 1:
                return num, key
    
    return None

def check_if_valid(sudoku_array, attempt, row, col):
    
    row_values = sudoku_array[row-1]


    col_values = []
    
    for i in range(len(row_values)):
        col_values.append(sudoku_array[i][col-1])

    if attempt in row_values or attempt in col_values:
        return False
    
    dimension = len(sudoku_array)

    

    sqrt = int(math.sqrt(dimension))
   

    top_row = (row // sqrt) * sqrt
    first_col = (col // sqrt) * sqrt

    

    for i in range(top_row, top_row + int(math.sqrt(dimension))):
        for j in range(first_col, first_col + int(math.sqrt(dimension))):
            if sudoku_array[i][j] == attempt:
                return False
            
    return True
    



def load_set_dicts(dimension, locations, sudoku_offset):
    dimension_set = set()
    set_dict_rows = {}
    set_dict_cols = {}
    set_dict_sub_square = {}
    if(dimension==9):
        dimension_set = {'1','2','3','4','5','6','7','8','9'}
    elif(dimension==16):
        dimension_set = {'1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G'}
    else:
        dimension_set = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 
        'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y'}
    for i in range(dimension):
        set_dict_rows[i+sudoku_offset] = dimension_set.copy()
        set_dict_cols[i+sudoku_offset] = dimension_set.copy()
        set_dict_sub_square[i+sudoku_offset] = dimension_set.copy()
    for key in locations:
        val = locations[key]
        set_dict_rows[key[0]].discard(val)
        set_dict_cols[key[1]].discard(val)
        sub_square_num = get_subsquare(dimension,key[0],key[1])
        set_dict_sub_square[sub_square_num].discard(val)
    return set_dict_rows,set_dict_cols,set_dict_sub_square

def get_subsquare(dimension,row,col):
    """
    This helper method takes an x,y cordinate and sudoku dimensions and returns what subsquare it is within
    This returns an int in which subsquare 1 top left corner and len(dimension) subsquare is the bottom right square
    """

    # Determine the size of each subsquare based on the given dimension
    subsquare_size = int(math.sqrt(dimension))

    # # # Determine the row and column of the subsquare based on the given coordinates
    subsquare_row = (row - 1) // subsquare_size
    subsquare_col = (col - 1) // subsquare_size
    
    # Determine the subsquare number based on the row and column
    subsquare_num = subsquare_row * (dimension // subsquare_size) + subsquare_col + 1

    return subsquare_num

# def solve_recursive(row,col,sudoku_array,sudoku_offset, possible_rows_dict, possible_cols_dict,possible_sub_square_dict,num_nodes):



def get_poss_vals(possible_rows_dict, possible_cols_dict,possible_sub_square_dict,row,col,sub_sqr_num):
    """
    This method gets the possible values to later be iterated over.
    This method returns a set of all possible values can be at row, col
    """
  
    return possible_rows_dict[row].intersection(possible_cols_dict[col], possible_sub_square_dict[sub_sqr_num])

    


def load_sudoku_array(sudoku_offset,locations):
    """
    This method creates the sudoku array.
    It returns an array where the pre-defined values are at their x,y cordinates.
        If there is no current val at that location then there is None at that cordinate
        It will also return a Queue of locations with no assigned value
    """
    open_points_queue = Queue()
    #find max row and col value by searching locations
    dimension = get_dimension(locations)
    sudoku_array = []
    for i in range(dimension):
        inner_array = []
        for j in range(dimension):
            try:
                val = locations[i+sudoku_offset,j+sudoku_offset]
                inner_array.append(val)
            except:
                open_points_queue.enqueue((i+sudoku_offset,j+sudoku_offset))
                inner_array.append(None)
        sudoku_array.append(inner_array)
    return sudoku_array,dimension, open_points_queue




def get_locations(filename):
    """
    This method is a helper method to load_sudoku_array to find pre defined locaitons
    It returns a dictonary  where key is the tuple location and val is the value at that location
    """
    locations = {}
    with open(filename, 'r') as f:
        for line in f:
            line_list = line.split()
            locations[int(line_list[0]),int(line_list[1])] = line_list[2]
    return locations

def get_dimension(locations):
    """
    This method finds the dimension to later be used for creating 2D array in Solve
    locations is dict where key is the tuple location and val is the value at that location
    """  
    dimension = 0
    for pair in locations.keys():
        if(pair[0]>dimension):
            dimension = pair[0]
    return dimension


# def get_next_row_col(sudoku_array, last_insert, sudoku_offset):
#     found = False
#     row = last_insert[0] 
#     col = last_insert[1]  

    

#     while not found:
        
#         if col != len(sudoku_array):
#             col += 1
#             cur = sudoku_array[row - sudoku_offset][ col - sudoku_offset]
#         else: 
#             row += 1
#             col = 1
#             cur = sudoku_array[row - sudoku_offset][col - sudoku_offset]

#         if cur == None:
#             found = True

#     return (row,col)


def get_next_row_col(sudoku_array, offset):

    for r in range(len(sudoku_array)):
        for c in range(len(sudoku_array)):

            #if this spot is empty
            if sudoku_array[r][c] == None:
                return r+1,c+1
            
    #if no more boxes to fill, puzzle complete
    return None, None


        




if __name__ == "__main__":
    SIZE = 9
    FILENAME = "p1.txt"
    solution = solve(SIZE, FILENAME)
    # if not solution[0]:
    #     print("No solution")
    # else:
    #     print(solution[0])
    # print(f"Nodes generated = {solution[1]}")